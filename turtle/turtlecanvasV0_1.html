<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Python + Turtle Runner (Editor + Turtle + Console)</title>

  <!-- CodeMirror 5 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/lib/codemirror.css">
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/lib/codemirror.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/mode/python/python.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/addon/edit/matchbrackets.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/addon/comment/comment.js"></script>

  <style>
    body { margin: 0; height: 100vh; display: flex; flex-direction: column; font-family: system-ui, sans-serif; }
    header { display: flex; gap: 10px; align-items: center; padding: 10px 12px; border-bottom: 1px solid #ddd; }
    #status { color: #666; font-size: 14px; }
    .spacer { flex: 1; }
    button { padding: 6px 12px; cursor: pointer; }
    select { padding: 6px 10px; border: 1px solid #ccc; border-radius: 8px; background: white; font-size: 14px; }

    #app { flex: 1; display: flex; min-height: 0; width: 100%; }
    #left, #right { display: flex; flex-direction: column; min-height: 0; flex: 1 1 0; min-width: 240px; }
    #left { border-right: 1px solid #ddd; }

    .pane-title {
      padding: 6px 12px;
      font-size: 14px;
      color: #444;
      border-bottom: 1px solid #eee;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .pane-title .spacer { flex: 1; }

    #splitter {
      width: 8px;
      cursor: col-resize;
      background: #f3f3f3;
      border-left: 1px solid #ddd;
      border-right: 1px solid #ddd;
      flex: 0 0 8px;
      user-select: none;
      touch-action: none;
    }

    #hsplitter {
      height: 8px;
      cursor: row-resize;
      background: #f3f3f3;
      border-top: 1px solid #ddd;
      border-bottom: 1px solid #ddd;
      flex: 0 0 8px;
      user-select: none;
      touch-action: none;
    }

    #consolePane {
      display: flex;
      flex-direction: column;
      min-height: 160px;
      flex: 1 1 0; /* helps keep console from resizing to content */
    }
    #editorWrap { flex: 1; min-height: 0; }
    .CodeMirror { height: 100% !important; font-size: 14px; line-height: 1.4; }
    .CodeMirror-gutters { border-right: 1px solid #eee; }

    #stageWrap { flex: 1; min-height: 0; background: #111; position: relative; }
    #stage, #overlay {
      position: absolute;
      left: 12px; top: 12px;
      width: calc(100% - 24px);
      height: calc(100% - 24px);
      border: 1px solid #333;
      display: block;
      box-sizing: border-box;
    }
    #stage { background: #111; z-index: 1; }
    #overlay { z-index: 5; pointer-events: none; }

    #consoleWrap { flex: 1; background: #0b0b0b; border-top: 1px solid #222; min-height: 160px; }
    #console {
      height: 100%;
      padding: 12px;
      overflow: auto;
      color: #eaeaea;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 14px;
      line-height: 1.4;
      white-space: pre-wrap;
      outline: none;
      cursor: text;
      background: #0b0b0b;
      box-sizing: border-box;
    }

    /* Terminal caret (input mode only) */
    .caret {
      display: inline-block;
      width: 8px;
      height: 1.2em;
      vertical-align: -0.2em;
      background: currentColor;
      animation: caretBlink 1s step-end infinite;
    }
    @keyframes caretBlink {
      50% { opacity: 0; }
    }
  </style>
</head>

<body>
<header>
  <label style="font-size:14px;color:#444;">test - Program:</label>
  <select id="program" disabled></select>

  <button id="run" disabled>Run ▶</button>
  <button id="stop">Stop ■</button>
  <label class="alphaCtl" title="Turtle transparency (alpha)">
    <span>α</span>
    <input id="alphaSlider" type="range" min="0.25" max="0.9" step="0.01" value="0.25">
    <span id="alphaVal">0.25</span>
  </label>
  <button id="reload" disabled>Reload ↻</button>

  <div class="spacer"></div>
  <div id="status">Loading…</div>
</header>

<div id="app">
  <section id="left">
    <div class="pane-title" id="filename">Editor</div>
    <div id="editorWrap"><textarea id="editor"></textarea></div>
  </section>

  <div id="splitter" title="Drag to resize"></div>

  <section id="right">
    <div class="pane-title" id="turtleTitle">Turtle</div>
    <div id="stageWrap">
      <canvas id="stage"></canvas>
      <canvas id="overlay"></canvas>
    </div>

    <div id="hsplitter" title="Drag to resize"></div>

    <div id="consolePane">
      <div class="pane-title">
        <span>Console</span>
        <div class="spacer"></div>
        <button id="clear">Clear console</button>
      </div>
      <div id="consoleWrap">
        <div id="console" tabindex="0"></div>
      </div>
    </div>

  </section>
</div>

<script type="module">
  const runBtn = document.getElementById("run");
  const stopBtn = document.getElementById("stop");
  const reloadBtn = document.getElementById("reload");
  const statusEl = document.getElementById("status");
  const programSel = document.getElementById("program");
  const filenameEl = document.getElementById("filename");
  const consoleEl = document.getElementById("console");
  const clearBtn = document.getElementById("clear");

  const alphaSlider = document.getElementById("alphaSlider");
  const alphaVal = document.getElementById("alphaVal");
  let turtleAlpha = alphaSlider ? parseFloat(alphaSlider.value) : 0.25;

  if (alphaSlider && alphaVal) {
    alphaVal.textContent = turtleAlpha.toFixed(2);
    alphaSlider.addEventListener("input", () => {
      turtleAlpha = parseFloat(alphaSlider.value);
      alphaVal.textContent = turtleAlpha.toFixed(2);
      redrawTurtle();
    });
  }

  const leftPane = document.getElementById("left");
  const rightPane = document.getElementById("right");
  const splitter = document.getElementById("splitter");
  const app = document.getElementById("app");

  const hsplitter = document.getElementById("hsplitter");
  const stageWrap = document.getElementById("stageWrap");
  const consolePane = document.getElementById("consolePane");
  const turtleTitle = document.getElementById("turtleTitle");

  const canvas = document.getElementById("stage");
  const ctx = canvas.getContext("2d");
  const overlay = document.getElementById("overlay");
  const octx = overlay.getContext("2d");

  const setStatus = (s) => statusEl.textContent = s;

  /* ---------- Editor ---------- */
  const cm = CodeMirror.fromTextArea(document.getElementById("editor"), {
    mode: "python",
    lineNumbers: true,
    indentUnit: 4,
    tabSize: 4,
    smartIndent: true,
    matchBrackets: true,
    extraKeys: {
      "Tab": cm => cm.replaceSelection("    ", "end"),
      "Shift-Tab": cm => cm.indentSelection("subtract")
    }
  });
  cm.setSize(null, "100%");

  /* ---------- Splitter ---------- */
  let dragging = false;
  function setLeftWidth(px) {
    const total = app.getBoundingClientRect().width;
    const minLeft = 240;
    const minRight = 280;
    const maxLeft = total - 8 - minRight;
    const clamped = Math.max(minLeft, Math.min(px, maxLeft));
    leftPane.style.flex = `0 0 ${clamped}px`;
    rightPane.style.flex = `1 1 0`;
    cm.refresh();
    fitAfterLayout();
  }
  splitter.addEventListener("pointerdown", (e) => {
    dragging = true;
    splitter.setPointerCapture(e.pointerId);
    document.body.style.cursor = "col-resize";
    document.body.style.userSelect = "none";
  });
  splitter.addEventListener("pointermove", (e) => {
    if (!dragging) return;
    const rect = app.getBoundingClientRect();
    setLeftWidth(e.clientX - rect.left);
  });
  splitter.addEventListener("pointerup", (e) => {
    dragging = false;
    try { splitter.releasePointerCapture(e.pointerId); } catch {}
    document.body.style.cursor = "";
    document.body.style.userSelect = "";
  });

  /* ---------- Horizontal splitter (Turtle vs Console) ---------- */
  let hDragging = false;

  function setStageHeight(px) {
    const rect = rightPane.getBoundingClientRect();
    const titleH = turtleTitle.getBoundingClientRect().height;
    const splitterH = hsplitter.getBoundingClientRect().height;

    const minStage = 180;
    const minConsole = 180;

    const totalBelowTitle = rect.height - titleH - splitterH;
    const maxStage = Math.max(minStage, totalBelowTitle - minConsole);

    const clamped = Math.max(minStage, Math.min(px, maxStage));

    stageWrap.style.flex = `0 0 ${clamped}px`;
    consolePane.style.flex = "1 1 0";

    fitAfterLayout();
  }

  hsplitter.addEventListener("pointerdown", (e) => {
    hDragging = true;
    hsplitter.setPointerCapture(e.pointerId);
    document.body.style.cursor = "row-resize";
    document.body.style.userSelect = "none";
  });

  hsplitter.addEventListener("pointermove", (e) => {
    if (!hDragging) return;
    const rect = rightPane.getBoundingClientRect();
    const titleH = turtleTitle.getBoundingClientRect().height;
    const y = e.clientY - rect.top;
    const desiredStage = y - titleH;
    setStageHeight(desiredStage);
  });

  hsplitter.addEventListener("pointerup", (e) => {
    hDragging = false;
    try { hsplitter.releasePointerCapture(e.pointerId); } catch {}
    document.body.style.cursor = "";
    document.body.style.userSelect = "";
  });

  /* ---------- Turtle state (displayed) ---------- */
  const turtleState = { x: 0, y: 0, heading: 0, visible: true, color: "#00ff66" };
  let logicalState = { x: 0, y: 0, heading: 0, visible: true, pencolor: "#00ff66" };

  function toCanvasXY(x, y) {
    const rect = canvas.getBoundingClientRect();
    return { cx: rect.width / 2 + x, cy: rect.height / 2 - y };
  }

  function overlayClear() {
    const rect = overlay.getBoundingClientRect();
    octx.clearRect(0, 0, rect.width, rect.height);
  }

  function redrawTurtle() {
    overlayClear();
    if (!turtleState.visible) return;

    const p = toCanvasXY(turtleState.x, turtleState.y);
    const size = 12;
    const ang = (turtleState.heading * Math.PI) / 180;

    const tip = { x: Math.cos(ang) * size, y: -Math.sin(ang) * size };
    const left = { x: Math.cos(ang + 2.5) * (size * 0.75), y: -Math.sin(ang + 2.5) * (size * 0.75) };
    const right = { x: Math.cos(ang - 2.5) * (size * 0.75), y: -Math.sin(ang - 2.5) * (size * 0.75) };

    octx.beginPath();
    octx.moveTo(p.cx + tip.x, p.cy + tip.y);
    octx.lineTo(p.cx + left.x, p.cy + left.y);
    octx.lineTo(p.cx + right.x, p.cy + right.y);
    octx.closePath();

    octx.fillStyle = turtleState.color || "#00ff66";
    octx.globalAlpha = turtleAlpha;
    octx.fill();
    octx.globalAlpha = 1;
  }

  /* ---------- Canvas sizing ---------- */
  let currentBg = "#111111";
  const strokes = [];

  function fitOneCanvas(c, context) {
    const rect = c.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    c.width = Math.max(1, Math.floor(rect.width * dpr));
    c.height = Math.max(1, Math.floor(rect.height * dpr));
    context.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  function canvasClear() {
    const rect = canvas.getBoundingClientRect();
    ctx.fillStyle = currentBg;
    ctx.fillRect(0, 0, rect.width, rect.height);
  }

  function redrawAll() {
    const rect = canvas.getBoundingClientRect();
    ctx.fillStyle = currentBg;
    ctx.fillRect(0, 0, rect.width, rect.height);

    for (const s of strokes) {
      drawSegment(s.x1, s.y1, s.x2, s.y2, s.color, s.width);
    }

    redrawTurtle();
  }

  function fitCanvases() {
    fitOneCanvas(canvas, ctx);
    fitOneCanvas(overlay, octx);
    redrawAll();
  }

  function fitAfterLayout() {
    requestAnimationFrame(() => {
      fitCanvases();
      requestAnimationFrame(() => fitCanvases());
    });
  }

  window.addEventListener("resize", () => { cm.refresh(); fitAfterLayout(); });

  // ✅ Fix for "console scroll messes up turtle Y": resize canvases when layout changes (not just window resize)
  const ro = new ResizeObserver(() => fitAfterLayout());
  ro.observe(stageWrap);

  fitAfterLayout();

  /* ---------- Ordered animation queue ---------- */

  const q = [];
  let animating = false;
  let timer = null;

  let lastLineWaitingForState = null;
  let lastKnownSpeed = 10;

  const MIN_TICKS_PER_SEGMENT = 8;

  function speedParams(speed) {
    let s = Number(speed);
    if (!Number.isFinite(s)) s = 10;
    if (s <= 0) return { instant: true, tickMs: 0, pxPerTick: Infinity };
    if (s > 10) s = 10;

    let tickMs;
    if (s <= 2) {
      tickMs = 128 + (20 - 128) * (s - 1);
    } else {
      const t = (s - 2) / 8;
      tickMs = 20 * Math.pow(1 / 20, t);
    }

    let pxPerTick;
    if (s <= 2) {
      pxPerTick = 5 + (28 - 5) * (s - 1);
    } else {
      const t = (s - 2) / 8;
      pxPerTick = 28 * Math.pow(200 / 28, t);
    }

    return {
      instant: false,
      tickMs: Math.max(1, Math.round(tickMs)),
      pxPerTick: Math.max(1, Math.round(pxPerTick)),
    };
  }

  function effectivePxPerTick(dist, pxPerTick) {
    const maxPxThisSegment = Math.max(1, dist / MIN_TICKS_PER_SEGMENT);
    return Math.min(pxPerTick, maxPxThisSegment);
  }

  function drawSegment(x1, y1, x2, y2, color, width) {
    const a = toCanvasXY(x1, y1);
    const b = toCanvasXY(x2, y2);
    ctx.strokeStyle = color || "#00ff66";
    ctx.lineWidth = Number(width || 2);
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(a.cx, a.cy);
    ctx.lineTo(b.cx, b.cy);
    ctx.stroke();
  }

  function applyStateToTurtle(s) {
    if (!s) return;
    turtleState.x = Number(s.x) || 0;
    turtleState.y = Number(s.y) || 0;
    turtleState.heading = Number(s.heading) || 0;
    turtleState.visible = !!s.visible;
    turtleState.color = s.pencolor || turtleState.color;
  }

  // (rest of your original code continues unchanged — included in full file)
  // NOTE: For brevity in this code cell we continue writing the remainder exactly as in the patched version you tested.

  /* ---------- Movement / line animation functions ---------- */
  function animateMove(from, to, speed, done) {
    const { instant, tickMs, pxPerTick } = speedParams(speed);
    const x1 = Number(from.x) || 0, y1 = Number(from.y) || 0;
    const x2 = Number(to.x) || 0, y2 = Number(to.y) || 0;

    const heading = Number(to.heading) || turtleState.heading;
    const visible = !!to.visible;
    const tColor = to.pencolor || turtleState.color;

    if (instant) {
      turtleState.x = x2; turtleState.y = y2;
      turtleState.heading = heading;
      turtleState.visible = visible;
      turtleState.color = tColor;
      redrawTurtle();
      done();
      return;
    }

    const dx = x2 - x1, dy = y2 - y1;
    const dist = Math.hypot(dx, dy);

    if (dist < 0.5) {
      turtleState.x = x2; turtleState.y = y2;
      turtleState.heading = heading;
      turtleState.visible = visible;
      turtleState.color = tColor;
      redrawTurtle();
      done();
      return;
    }

    const stepPx = effectivePxPerTick(dist, pxPerTick);
    let travelled = 0;
    const myToken = cancelToken;

    const step = () => {
      if (myToken !== cancelToken) return;
      const nextTravel = Math.min(dist, travelled + stepPx);
      const t = nextTravel / dist;

      turtleState.x = x1 + dx * t;
      turtleState.y = y1 + dy * t;
      turtleState.heading = heading;
      turtleState.visible = visible;
      turtleState.color = tColor;
      redrawTurtle();

      travelled = nextTravel;

      if (travelled >= dist - 1e-6) {
        turtleState.x = x2; turtleState.y = y2;
        redrawTurtle();
        done();
        return;
      }

      timer = setTimeout(step, tickMs);
    };
    step();
  }

  function animateLine(cmd, done) {
    const { instant, tickMs, pxPerTick } = speedParams(cmd.speed);
    const endState = cmd.endState;

    const heading = Number(endState.heading) || turtleState.heading;
    const visible = !!endState.visible;
    const tColor = endState.pencolor || turtleState.color;

    if (instant) {
      drawSegment(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.color, cmd.width);
      strokes.push({ x1: Number(cmd.x1)||0, y1: Number(cmd.y1)||0, x2: Number(cmd.x2)||0, y2: Number(cmd.y2)||0, color: cmd.color, width: cmd.width });
      applyStateToTurtle(endState);
      redrawTurtle();
      done();
      return;
    }

    const x1 = Number(cmd.x1) || 0, y1 = Number(cmd.y1) || 0;
    const x2 = Number(cmd.x2) || 0, y2 = Number(cmd.y2) || 0;
    const dx = x2 - x1, dy = y2 - y1;
    const dist = Math.hypot(dx, dy);

    if (dist < 0.5) {
      drawSegment(x1, y1, x2, y2, cmd.color, cmd.width);
      strokes.push({ x1, y1, x2, y2, color: cmd.color, width: cmd.width });
      applyStateToTurtle(endState);
      redrawTurtle();
      done();
      return;
    }

    const stepPx = effectivePxPerTick(dist, pxPerTick);
    let travelled = 0;
    let lastX = x1, lastY = y1;
    const myToken = cancelToken;

    const step = () => {
      if (myToken !== cancelToken) return;
      const nextTravel = Math.min(dist, travelled + stepPx);
      const t = nextTravel / dist;

      const curX = x1 + dx * t;
      const curY = y1 + dy * t;

      drawSegment(lastX, lastY, curX, curY, cmd.color, cmd.width);

      turtleState.x = curX;
      turtleState.y = curY;
      turtleState.heading = heading;
      turtleState.visible = visible;
      turtleState.color = tColor;
      redrawTurtle();

      travelled = nextTravel;
      lastX = curX; lastY = curY;

      if (travelled >= dist - 1e-6) {
        strokes.push({ x1, y1, x2, y2, color: cmd.color, width: cmd.width });
        applyStateToTurtle(endState);
        redrawTurtle();
        done();
        return;
      }

      timer = setTimeout(step, tickMs);
    };
    step();
  }

  function runQueue() {
    if (animating) return;
    animating = true;

    const next = () => {
      if (!q.length) {
        animating = false;
        timer = null;
        return;
      }

      const item = q.shift();

      if (item.kind === "state") {
        applyStateToTurtle(item.state);
        redrawTurtle();
        next();
        return;
      }

      if (item.kind === "move") {
        animateMove(item.from, item.to, item.speed, next);
        return;
      }

      if (item.kind === "line") {
        if (!item.endState) {
          q.unshift(item);
          animating = false;
          return;
        }
        animateLine(item, next);
        return;
      }
    };

    next();
  }

  function resetQueues() {
    cancelToken++;
    if (timer) { clearTimeout(timer); timer = null; }
    q.length = 0;
    animating = false;
    lastLineWaitingForState = null;
  }

  function handleCanvasCmd(cmd) {
    if (!cmd || !cmd.type) return;

    if (cmd.type === "bg") {
      currentBg = cmd.color || "#111111";
      strokes.length = 0;
      resetQueues();
      canvasClear();
      redrawTurtle();
      return;
    }

    if (cmd.type === "clear") {
      strokes.length = 0;
      resetQueues();
      canvasClear();
      redrawTurtle();
      return;
    }

    if (cmd.type === "line") {
      lastKnownSpeed = cmd.speed ?? lastKnownSpeed;

      const lineItem = {
        kind: "line",
        x1: cmd.x1, y1: cmd.y1,
        x2: cmd.x2, y2: cmd.y2,
        color: cmd.color,
        width: cmd.width,
        speed: cmd.speed,
        endState: null
      };

      q.push(lineItem);
      lastLineWaitingForState = lineItem;
      runQueue();
      return;
    }

    if (cmd.type === "turtle") {
      const nextState = {
        x: Number(cmd.x) || 0,
        y: Number(cmd.y) || 0,
        heading: Number(cmd.heading) || 0,
        visible: !!cmd.visible,
        pencolor: cmd.pencolor || logicalState.pencolor
      };

      if (lastLineWaitingForState && !lastLineWaitingForState.endState) {
        lastLineWaitingForState.endState = nextState;
        lastLineWaitingForState = null;
        logicalState = nextState;
        runQueue();
        return;
      }

      const moved = (nextState.x !== logicalState.x) || (nextState.y !== logicalState.y);
      const headingChanged = nextState.heading !== logicalState.heading;
      const visChanged = nextState.visible !== logicalState.visible;
      const colorChanged = nextState.pencolor !== logicalState.pencolor;

      if (moved) {
        q.push({ kind: "move", from: logicalState, to: nextState, speed: lastKnownSpeed });
      } else if (headingChanged || visChanged || colorChanged) {
        q.push({ kind: "state", state: nextState });
      }

      logicalState = nextState;
      runQueue();
      return;
    }
  }

  /* ---------- Console (seamless input) ---------- */

  let inputActive = false;
  let inputBuffer = "";
  let caretEl = null;

  function ensureCaret() {
    if (caretEl && caretEl.isConnected) return;
    caretEl = document.createElement("span");
    caretEl.className = "caret";
    consoleEl.appendChild(caretEl);
  }

  function removeCaret() {
    if (caretEl && caretEl.isConnected) caretEl.remove();
  }

  function scrollConsoleToBottom() {
    consoleEl.scrollTop = consoleEl.scrollHeight;
  }

  function write(s = "") {
    removeCaret();
    if (s !== "") consoleEl.appendChild(document.createTextNode(String(s)));
    if (inputActive) ensureCaret();
    scrollConsoleToBottom();
  }

  function writeln(s = "") {
    write(String(s) + "\n");
  }

  function clearConsole() {
    consoleEl.textContent = "";
    caretEl = null;
    inputActive = false;
    inputBuffer = "";
  }

  clearBtn.onclick = () => { clearConsole(); consoleEl.focus(); };

  function beginInput(prompt) {
    inputActive = true;
    inputBuffer = "";
    if (prompt) write(String(prompt));
    ensureCaret();
    consoleEl.focus();
  }

  function cancelInputUI() {
    inputActive = false;
    inputBuffer = "";
    removeCaret();
  }

  consoleEl.addEventListener("pointerdown", () => consoleEl.focus());

  consoleEl.addEventListener("keydown", (e) => {
    if (!inputActive) return;

    if (e.ctrlKey || e.metaKey) {
      if (e.key.toLowerCase() === "c" || e.key.toLowerCase() === "a") return;
    }

    e.preventDefault();

    if (e.key === "Enter") {
      write("\n");
      inputActive = false;
      removeCaret();
      worker?.postMessage({ type: "input_response", text: inputBuffer });
      inputBuffer = "";
      return;
    }

    if (e.key === "Backspace") {
      if (!inputBuffer.length) return;
      inputBuffer = inputBuffer.slice(0, -1);

      removeCaret();
      const last = consoleEl.lastChild;
      if (last && last.nodeType === Node.TEXT_NODE) {
        last.textContent = last.textContent.slice(0, -1);
        if (last.textContent.length === 0) last.remove();
      } else if (last) {
        consoleEl.textContent = consoleEl.textContent.slice(0, -1);
      }
      ensureCaret();
      scrollConsoleToBottom();
      return;
    }

    if (e.key.length === 1) {
      inputBuffer += e.key;
      write(e.key);
      return;
    }
  });

  consoleEl.addEventListener("paste", (e) => {
    if (!inputActive) return;
    e.preventDefault();
    const text = (e.clipboardData || window.clipboardData).getData("text");
    if (!text) return;
    inputBuffer += text;
    write(text);
  });

  /* ---------- Programs ---------- */
  let currentFile = null;

  async function loadProgramList() {
    const res = await fetch("./programs.json", { cache: "no-store" });
    const files = await res.json();
    programSel.innerHTML = "";
    for (const f of files) programSel.add(new Option(f, f));
    return files[0];
  }

  async function loadProgram(file) {
    setStatus("Loading " + file + "…");
    const res = await fetch("./" + file, { cache: "no-store" });
    const text = await res.text();
    currentFile = file;
    cm.setValue(text);
    filenameEl.textContent = file;
    programSel.value = file;
    setStatus("Ready");
  }

  programSel.addEventListener("change", async () => {
    await loadProgram(programSel.value);
  });

  reloadBtn.addEventListener("click", async () => {
    await loadProgram(programSel.value);
  });

  /* ---------- Worker ---------- */
  let worker = null;
  let running = false;

  let acceptCanvas = true;
  let cancelToken = 0;

  function makeWorker() {
    const w = new Worker("./py_worker.js?v=cursor8", { type: "module" });

    w.onmessage = (ev) => {
      const m = ev.data || {};
      if (m.type === "stdout") writeln(m.text ?? "");
      if (m.type === "stderr") writeln(m.text ?? "");
      if (m.type === "status") setStatus(m.text ?? "");
      if (m.type === "canvas_cmd") {
        if (!acceptCanvas) return;
        handleCanvasCmd(m.cmd);
      }

      if (m.type === "input_request") {
        beginInput(m.prompt ?? "");
      }

      if (m.type === "ready") {
        setStatus("Ready");
        runBtn.disabled = false;
        stopBtn.disabled = false;
      }
      if (m.type === "done") {
        running = false;
        runBtn.disabled = false;
        stopBtn.disabled = false;
        setStatus("Done");
        cancelInputUI();
      }
      if (m.type === "error") {
        running = false;
        runBtn.disabled = false;
        stopBtn.disabled = false;
        setStatus("Error");
        writeln(String(m.text ?? ""));
        cancelInputUI();
      }
    };

    w.postMessage({ type: "init" });
    return w;
  }

  function stopExecution(reason = "Stopped") {
    acceptCanvas = false;
    resetQueues();
    cancelInputUI();

    writeln("Program stopped by user.");
    try { worker?.terminate(); } catch {}
    worker = makeWorker();
    running = false;
    runBtn.disabled = false;
    stopBtn.disabled = false;
    setStatus(reason);
  }

  stopBtn.addEventListener("click", () => stopExecution("Stopped"));
  worker = makeWorker();

  runBtn.onclick = () => {
    clearConsole();
    resetQueues();
    strokes.length = 0;

    currentBg = "#111111";
    canvasClear();

    logicalState = { x: 0, y: 0, heading: 0, visible: true, pencolor: "#00ff66" };
    turtleState.x = 0; turtleState.y = 0; turtleState.heading = 0;
    turtleState.visible = true; turtleState.color = "#00ff66";
    redrawTurtle();

    running = true;
    acceptCanvas = true;
    runBtn.disabled = true;
    stopBtn.disabled = false;
    setStatus("Running…");
    worker.postMessage({ type: "run", code: cm.getValue() });
  };

  /* ---------- Init ---------- */
  (async () => {
    setStatus("Loading…");
    const first = await loadProgramList();
    await loadProgram(first);
    programSel.disabled = false;
    runBtn.disabled = false;
    reloadBtn.disabled = false;
    stopBtn.disabled = false;
    setStatus("Ready");
  })();
</script>
</body>
</html>
