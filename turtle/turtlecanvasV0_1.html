<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Python Runner (Editor + Console)</title>

  <!-- CodeMirror 5 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/lib/codemirror.css">
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/lib/codemirror.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/mode/python/python.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/addon/edit/matchbrackets.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/addon/comment/comment.js"></script>

  <style>
    body { margin: 0; height: 100vh; display: flex; flex-direction: column; font-family: system-ui, sans-serif; }
    header { display: flex; gap: 10px; align-items: center; padding: 10px 12px; border-bottom: 1px solid #ddd; }
    #status { color: #666; font-size: 14px; }
    .spacer { flex: 1; }
    button { padding: 6px 12px; cursor: pointer; }
    select { padding: 6px 10px; border: 1px solid #ccc; border-radius: 8px; background: white; font-size: 14px; }

    #app { flex: 1; display: flex; min-height: 0; width: 100%; }
    #left, #right { display: flex; flex-direction: column; min-height: 0; flex: 1 1 0; min-width: 220px; }

    .pane-title {
      padding: 6px 12px;
      font-size: 14px;
      color: #444;
      border-bottom: 1px solid #eee;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .pane-title .spacer { flex: 1; }

    #splitter {
      width: 8px;
      cursor: col-resize;
      background: #f3f3f3;
      border-left: 1px solid #ddd;
      border-right: 1px solid #ddd;
      flex: 0 0 8px;
      user-select: none;
      touch-action: none;
    }
    #splitter:hover { background: #e9e9e9; }

    #editorWrap { flex: 1; min-height: 0; }
    .CodeMirror { height: 100% !important; font-size: 14px; line-height: 1.4; }
    .CodeMirror-gutters { background: #fafafa; border-right: 1px solid #eee; }

    #stageWrap { flex: 1; min-height: 0; position: relative; background: #fff; overflow: hidden; }
    #stage { position: absolute; inset: 0; width: 100%; height: 100%; background: #fff; }

    #consoleDock {
      position: absolute;
      right: 14px;
      bottom: 14px;
      width: min(420px, 46vw);
      height: min(240px, 40vh);
      border: 1px solid #ddd;
      background: rgba(255,255,255,.95);
      border-radius: 10px;
      box-shadow: 0 8px 24px rgba(0,0,0,.12);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    #consoleTitle {
      padding: 6px 10px;
      background: #f6f6f6;
      border-bottom: 1px solid #e6e6e6;
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #consoleTitle .spacer { flex: 1; }
    #console {
      flex: 1;
      padding: 8px 10px;
      overflow: auto;
      font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      white-space: pre-wrap;
    }
    #consoleInputRow {
      display: none;
      border-top: 1px solid #eee;
      padding: 6px 8px;
      gap: 6px;
      align-items: center;
      background: #fff;
    }
    #consolePrompt {
      font: 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      color: #444;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 55%;
    }
    #consoleInput {
      flex: 1;
      padding: 6px 8px;
      border: 1px solid #ccc;
      border-radius: 8px;
      font: 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }
    #consoleSend {
      padding: 6px 10px;
    }

    /* simple help text */
    .hint { color:#777; font-size:12px; padding: 6px 12px 10px; border-top: 1px solid #eee; }
  </style>
</head>

<body>
<header>
  <button id="runBtn" disabled>Run</button>
  <button id="stopBtn" disabled>Stop</button>
  <span id="status">Loading…</span>
  <span class="spacer"></span>

  <label style="display:flex; gap:8px; align-items:center;">
    <span style="font-size:13px; color:#555;">Program:</span>
    <select id="programSel"></select>
  </label>

  <button id="uploadBtn">Upload…</button>
  <input id="fileInput" type="file" accept=".py,.txt" style="display:none" />
</header>

<div id="app">
  <div id="left">
    <div class="pane-title">
      <strong>Editor</strong>
      <span class="spacer"></span>
      <span id="filename" style="font-size:12px; color:#666;"></span>
      <button id="saveBtn" disabled>Save</button>
      <button id="resetBtn" disabled>Reset</button>
    </div>
    <div id="editorWrap"><textarea id="editor"></textarea></div>
    <div class="hint">Ctrl-/ to toggle comment · Ctrl-S to Save</div>
  </div>

  <div id="splitter" title="Drag to resize"></div>

  <div id="right">
    <div class="pane-title">
      <strong>Stage</strong>
      <span class="spacer"></span>
      <button id="clearStageBtn">Clear</button>
    </div>

    <div id="stageWrap">
      <canvas id="stage"></canvas>

      <div id="consoleDock">
        <div id="consoleTitle">
          <strong>Python output</strong>
          <span class="spacer"></span>
          <button id="clearConsoleBtn">Clear</button>
        </div>

        <div id="console" tabindex="0"></div>

        <div id="consoleInputRow">
          <div id="consolePrompt"></div>
          <input id="consoleInput" type="text" autocomplete="off" />
          <button id="consoleSend">Send</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(async () => {
  /* ---------- Elements ---------- */
  const runBtn = document.getElementById("runBtn");
  const stopBtn = document.getElementById("stopBtn");
  const statusEl = document.getElementById("status");

  const programSel = document.getElementById("programSel");
  const uploadBtn = document.getElementById("uploadBtn");
  const fileInput = document.getElementById("fileInput");

  const filenameEl = document.getElementById("filename");
  const saveBtn = document.getElementById("saveBtn");
  const resetBtn = document.getElementById("resetBtn");

  const stage = document.getElementById("stage");
  const stageWrap = document.getElementById("stageWrap");
  const clearStageBtn = document.getElementById("clearStageBtn");

  const consoleDock = document.getElementById("consoleDock");
  const consoleEl = document.getElementById("console");
  const clearConsoleBtn = document.getElementById("clearConsoleBtn");

  const consoleInputRow = document.getElementById("consoleInputRow");
  const consolePromptEl = document.getElementById("consolePrompt");
  const consoleInput = document.getElementById("consoleInput");
  const consoleSend = document.getElementById("consoleSend");

  const splitter = document.getElementById("splitter");
  const leftPane = document.getElementById("left");
  const rightPane = document.getElementById("right");

  /* ---------- Helpers ---------- */
  function setStatus(t) { statusEl.textContent = t; }

  function writeln(s) {
    const text = String(s ?? "");
    consoleEl.textContent += text;
    if (!text.endsWith("\n")) consoleEl.textContent += "\n";
    consoleEl.scrollTop = consoleEl.scrollHeight;
  }
  function clearConsole() {
    consoleEl.textContent = "";
  }

  clearConsoleBtn.onclick = () => clearConsole();

  /* ---------- Stage sizing ---------- */
  function resizeCanvas() {
    const rect = stageWrap.getBoundingClientRect();
    stage.width = Math.max(1, Math.floor(rect.width));
    stage.height = Math.max(1, Math.floor(rect.height));
    // If your turtle renderer uses the canvas, it should read stage.width/height.
  }
  window.addEventListener("resize", resizeCanvas);
  resizeCanvas();

  clearStageBtn.onclick = () => {
    const ctx = stage.getContext("2d");
    ctx.clearRect(0, 0, stage.width, stage.height);
  };

  /* ---------- Splitter (resizable panes) ---------- */
  let dragging = false;
  splitter.addEventListener("pointerdown", (e) => {
    dragging = true;
    splitter.setPointerCapture(e.pointerId);
  });
  splitter.addEventListener("pointermove", (e) => {
    if (!dragging) return;
    const rect = document.getElementById("app").getBoundingClientRect();
    const x = e.clientX - rect.left;
    const pct = Math.min(80, Math.max(20, (x / rect.width) * 100));
    leftPane.style.flex = `0 0 ${pct}%`;
    rightPane.style.flex = `0 0 ${100 - pct}%`;
    resizeCanvas();
    cm.refresh();
  });
  splitter.addEventListener("pointerup", () => dragging = false);
  splitter.addEventListener("pointercancel", () => dragging = false);

  /* ---------- Editor ---------- */
  const cm = CodeMirror.fromTextArea(document.getElementById("editor"), {
    mode: "python",
    lineNumbers: true,
    matchBrackets: true,
    indentUnit: 4,
    tabSize: 4,
    extraKeys: {
      "Ctrl-/": "toggleComment",
      "Cmd-/": "toggleComment",
      "Ctrl-S": () => saveCurrent(),
      "Cmd-S": () => saveCurrent(),
    }
  });

  /* ---------- Programs + Upload ---------- */
  const uploadedText = new Map();   // filename -> content
  const originals = new Map();      // filename -> original content
  const fileHandles = new Map();    // filename -> File
  let currentFile = "";
  let previousSelectValue = "";

  async function loadProgramList() {
    // Your original version probably expects a file list next to this HTML.
    // We'll keep your existing "programs.txt" behavior:
    // programs.txt should contain one filename per line.
    let list = [];
    try {
      const res = await fetch("./programs.txt", { cache: "no-store" });
      if (res.ok) {
        list = (await res.text()).split("\n").map(s => s.trim()).filter(Boolean);
      }
    } catch {}
    if (!list.length) list = ["example.py"];

    programSel.innerHTML = "";
    for (const f of list) {
      const opt = document.createElement("option");
      opt.value = f;
      opt.textContent = f;
      programSel.appendChild(opt);
    }
    previousSelectValue = list[0];
    return list[0];
  }

  async function readFromHandle(file) {
    return await file.text();
  }

  function setSaveButtons() {
    const text = cm.getValue();
    const orig = originals.get(currentFile) ?? "";
    const dirty = text !== orig;
    saveBtn.disabled = !dirty;
    resetBtn.disabled = !dirty;
  }

  cm.on("change", () => setSaveButtons());

  async function saveCurrent() {
    if (!currentFile) return;
    uploadedText.set(currentFile, cm.getValue());
    originals.set(currentFile, cm.getValue());
    setSaveButtons();
    setStatus("Saved");
  }

  function resetCurrent() {
    if (!currentFile) return;
    const orig = originals.get(currentFile) ?? "";
    cm.setValue(orig);
    setSaveButtons();
    setStatus("Reset");
  }

  saveBtn.onclick = () => saveCurrent();
  resetBtn.onclick = () => resetCurrent();

  uploadBtn.onclick = () => fileInput.click();
  fileInput.onchange = async () => {
    const f = fileInput.files?.[0];
    if (!f) return;

    const text = await f.text();
    uploadedText.set(f.name, text);
    originals.set(f.name, text);
    fileHandles.set(f.name, f);

    // Add to dropdown if needed
    if (![...programSel.options].some(o => o.value === f.name)) {
      const opt = document.createElement("option");
      opt.value = f.name;
      opt.textContent = f.name;
      programSel.appendChild(opt);
    }

    await loadProgram(f.name);
    fileInput.value = "";
  };

  /* ---------- Console input (async input()) ---------- */
  let waitingForInput = false;

  function beginInput(promptText) {
    waitingForInput = true;
    consoleInputRow.style.display = "flex";
    consolePromptEl.textContent = promptText || "";
    consoleInput.value = "";
    consoleInput.focus();
  }

  function removeCaret() {
    // no-op placeholder (kept for compatibility with your previous structure)
  }

  function cancelInputIfAny() {
    if (!waitingForInput) return;
    waitingForInput = false;
    consoleInputRow.style.display = "none";
    consolePromptEl.textContent = "";
    consoleInput.value = "";
  }

  function sendInput() {
    if (!waitingForInput) return;
    const val = consoleInput.value;
    cancelInputIfAny();
    worker?.postMessage({ type: "input_response", text: val });
  }

  consoleSend.onclick = () => sendInput();
  consoleInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      sendInput();
    }
  });

  /* ---------- Worker run control ---------- */
  let worker = null;
  let running = false;
  let runId = 0; // increments each time you run/stop; used to ignore stale worker messages

  function makeWorker() {
    const w = new Worker("./py_worker.js", { type: "module" });
    w.onmessage = (ev) => {
      const m = ev.data || {};
      // Ignore messages from older runs (e.g., after Stop)
      if (m.runId && m.runId !== runId) return;

      if (m.type === "stdout") writeln(m.text ?? "");
      if (m.type === "stderr") writeln(m.text ?? "");
      if (m.type === "status") setStatus(m.text ?? "");
      if (m.type === "ready") {
        setStatus("Ready");
        runBtn.disabled = false;
        stopBtn.disabled = true;
      }
      if (m.type === "done") {
        running = false;
        runBtn.disabled = false;
        stopBtn.disabled = true;
        setStatus("Done");
      }
      if (m.type === "error") {
        running = false;
        runBtn.disabled = false;
        stopBtn.disabled = true;
        setStatus("Error");
        writeln(String(m.text ?? ""));
      }
      if (m.type === "input_request") {
        beginInput(m.prompt ?? "");
      }
    };
    w.postMessage({ type: "init" });
    return w;
  }

  function stopExecution(reason = "Stopped") {
    const shouldAnnounce = (running || waitingForInput);

    // Invalidate any late messages from the current run
    runId += 1;

    cancelInputIfAny();

    // Terminate and recreate the worker so Python stops immediately
    try { worker?.terminate(); } catch {}
    worker = makeWorker();

    running = false;
    runBtn.disabled = false;
    stopBtn.disabled = true;
    setStatus(reason);

    if (shouldAnnounce) {
      writeln("Program stopped by user");
    }
  }

  // Stop button
  stopBtn.addEventListener("click", () => stopExecution("Stopped"));

  // start worker immediately
  worker = makeWorker();

  async function loadProgram(file) {
    stopExecution("Stopped");

    removeCaret();
    clearConsole();
    setStatus("Loading " + file + "…");

    let text;
    if (fileHandles.has(file)) {
      text = await readFromHandle(fileHandles.get(file));
      uploadedText.set(file, text);
      originals.set(file, text);
    } else if (uploadedText.has(file)) {
      text = uploadedText.get(file);
      originals.set(file, text);
    } else {
      const res = await fetch("./" + file, { cache: "no-store" });
      text = await res.text();
      originals.set(file, text);
    }

    currentFile = file;
    cm.setValue(text);
    filenameEl.textContent = file;

    programSel.value = file;
    previousSelectValue = file;

    if (uploadedText.has(file)) setStatus(fileHandles.has(file) ? "Ready (opened)" : "Ready (uploaded)");
    else setStatus("Ready");

    setSaveButtons();
    consoleEl.focus();
  }

  programSel.addEventListener("change", async () => {
    const next = programSel.value;
    if (!next) return;
    previousSelectValue = next;
    await loadProgram(next);
  });

  /* ---------- Run ---------- */
  runBtn.onclick = () => {
    clearConsole();
    if (!worker) worker = makeWorker();
    running = true;
    runBtn.disabled = true;
    stopBtn.disabled = false;
    setStatus("Running…");
    runId += 1;
    worker.postMessage({ type: "run", code: cm.getValue(), runId });
    consoleEl.focus();
  };

  /* ---------- UI init ---------- */
  const first = await loadProgramList();
  await loadProgram(first);

  // enable UI (worker loads async)
  setStatus("Loading Python…");
})();
</script>

</body>
</html>
