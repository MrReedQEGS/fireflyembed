<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Python + Turtle Runner (Editor + Turtle + Console)</title>

  <!-- CodeMirror 5 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/lib/codemirror.css">
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/lib/codemirror.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/mode/python/python.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/addon/edit/matchbrackets.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/addon/comment/comment.js"></script>

  <style>
    body { margin: 0; height: 100vh; display: flex; flex-direction: column; font-family: system-ui, sans-serif; }
    header { display: flex; gap: 10px; align-items: center; padding: 10px 12px; border-bottom: 1px solid #ddd; }
    #status { color: #666; font-size: 14px; }
    .spacer { flex: 1; }
    button { padding: 6px 12px; cursor: pointer; }
    select { padding: 6px 10px; border: 1px solid #ccc; border-radius: 8px; background: white; font-size: 14px; }

    #app { flex: 1; display: flex; min-height: 0; width: 100%; }
    #left, #right { display: flex; flex-direction: column; min-height: 0; flex: 1 1 0; min-width: 240px; }
    #left { border-right: 1px solid #ddd; }

    .pane-title {
      padding: 6px 12px;
      font-size: 14px;
      color: #444;
      border-bottom: 1px solid #eee;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .pane-title .spacer { flex: 1; }

    #splitter {
      width: 8px;
      cursor: col-resize;
      background: #f3f3f3;
      border-left: 1px solid #ddd;
      border-right: 1px solid #ddd;
      flex: 0 0 8px;
      user-select: none;
      touch-action: none;
    }

    #hsplitter {
      height: 8px;
      cursor: row-resize;
      background: #f3f3f3;
      border-top: 1px solid #ddd;
      border-bottom: 1px solid #ddd;
      flex: 0 0 8px;
      user-select: none;
      touch-action: none;
    }

    #consolePane {
      display: flex;
      flex-direction: column;
      min-height: 160px;
      flex: 1 1 0; /* helps keep console from resizing to content */
    }
    #editorWrap { flex: 1; min-height: 0; }
    .CodeMirror { height: 100% !important; font-size: 14px; line-height: 1.4; }
    .CodeMirror-gutters { border-right: 1px solid #eee; }

    #stageWrap { flex: 1; min-height: 0; background: #111; position: relative; }
    #stage, #overlay {
      position: absolute;
      left: 12px; top: 12px;
      width: calc(100% - 24px);
      height: calc(100% - 24px);
      border: 1px solid #333;
      display: block;
      box-sizing: border-box;
    }
    #stage { background: #111; z-index: 1; }
    #overlay { z-index: 5; pointer-events: none; }

    #consoleWrap { flex: 1; background: #0b0b0b; border-top: 1px solid #222; min-height: 160px; }
    #console {
      height: 100%;
      padding: 12px;
      overflow: auto;
      color: #eaeaea;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 14px;
      line-height: 1.4;
      white-space: pre-wrap;
      outline: none;
      cursor: text;
      background: #0b0b0b;
      box-sizing: border-box;
    }

    /* Terminal caret (input mode only) */
    .caret {
      display: inline-block;
      width: 8px;
      height: 1.2em;
      vertical-align: -0.2em;
      background: currentColor;
      animation: caretBlink 1s step-end infinite;
    }
    @keyframes caretBlink {
      50% { opacity: 0; }
    }
  </style>
</head>

<body>
<header>
  <label style="font-size:14px;color:#444;">Mr Reed - Dev v0.2 - Program:</label>
  <select id="program" disabled></select>

  <button id="run" disabled>Run ▶</button>
  <button id="stop">Stop ■</button>
  <label class="alphaCtl" title="Turtle transparency (alpha)">
    <span>α</span>
    <input id="alphaSlider" type="range" min="0.25" max="0.9" step="0.01" value="0.25">
    <span id="alphaVal">0.25</span>
  </label>
  <button id="reload" disabled>Reload ↻</button>

  <div class="spacer"></div>
  <div id="status">Loading…</div>
</header>

<div id="app">
  <section id="left">
    <div class="pane-title" id="filename">Editor</div>
    <div id="editorWrap"><textarea id="editor"></textarea></div>
  </section>

  <div id="splitter" title="Drag to resize"></div>

  <section id="right">
    <div class="pane-title" id="turtleTitle">Turtle</div>
    <div id="stageWrap">
      <canvas id="stage"></canvas>
      <canvas id="overlay"></canvas>
    </div>

    <div id="hsplitter" title="Drag to resize"></div>

    <div id="consolePane">
      <div class="pane-title">
        <span>Console</span>
        <div class="spacer"></div>
        <button id="clear">Clear console</button>
      </div>
      <div id="consoleWrap">
        <div id="console" tabindex="0"></div>
      </div>
    </div>

  </section>
</div>

<script type="module">
  const runBtn = document.getElementById("run");
  const stopBtn = document.getElementById("stop");
  const reloadBtn = document.getElementById("reload");
  const statusEl = document.getElementById("status");
  const programSel = document.getElementById("program");
  const filenameEl = document.getElementById("filename");
  const consoleEl = document.getElementById("console");
  const clearBtn = document.getElementById("clear");

  const alphaSlider = document.getElementById("alphaSlider");
  const alphaVal = document.getElementById("alphaVal");
  let turtleAlpha = alphaSlider ? parseFloat(alphaSlider.value) : 0.25;

  if (alphaSlider && alphaVal) {
    alphaVal.textContent = turtleAlpha.toFixed(2);
    alphaSlider.addEventListener("input", () => {
      turtleAlpha = parseFloat(alphaSlider.value);
      alphaVal.textContent = turtleAlpha.toFixed(2);
      redrawTurtle();
    });
  }

  const leftPane = document.getElementById("left");
  const rightPane = document.getElementById("right");
  const splitter = document.getElementById("splitter");
  const app = document.getElementById("app");

  const hsplitter = document.getElementById("hsplitter");
  const stageWrap = document.getElementById("stageWrap");
  const consolePane = document.getElementById("consolePane");
  const turtleTitle = document.getElementById("turtleTitle");

  const canvas = document.getElementById("stage");
  const ctx = canvas.getContext("2d");
  const overlay = document.getElementById("overlay");
  const octx = overlay.getContext("2d");

  const setStatus = (s) => statusEl.textContent = s;

  /* ---------- Editor ---------- */
  const cm = CodeMirror.fromTextArea(document.getElementById("editor"), {
    mode: "python",
    lineNumbers: true,
    indentUnit: 4,
    tabSize: 4,
    smartIndent: true,
    matchBrackets: true,
    extraKeys: {
      "Tab": cm => {
        if (cm.somethingSelected()) {
          cm.indentSelection("add");
        } else {
          cm.replaceSelection("    ", "end");
        }
      },
      "Shift-Tab": cm => cm.indentSelection("subtract")
    }
  });
  cm.setSize(null, "100%");

  /* ---------- Splitter ---------- */
  let dragging = false;
  function setLeftWidth(px) {
    const total = app.getBoundingClientRect().width;
    const minLeft = 240;
    const minRight = 280;
    const maxLeft = total - 8 - minRight;
    const clamped = Math.max(minLeft, Math.min(px, maxLeft));
    leftPane.style.flex = `0 0 ${clamped}px`;
    rightPane.style.flex = `1 1 0`;
    cm.refresh();
    fitAfterLayout();
  }
  splitter.addEventListener("pointerdown", (e) => {
    dragging = true;
    splitter.setPointerCapture(e.pointerId);
    document.body.style.cursor = "col-resize";
    document.body.style.userSelect = "none";
  });
  splitter.addEventListener("pointermove", (e) => {
    if (!dragging) return;
    const rect = app.getBoundingClientRect();
    setLeftWidth(e.clientX - rect.left);
  });
  splitter.addEventListener("pointerup", (e) => {
    dragging = false;
    try { splitter.releasePointerCapture(e.pointerId); } catch {}
    document.body.style.cursor = "";
    document.body.style.userSelect = "";
  });

  /* ---------- Horizontal splitter (Turtle vs Console) ---------- */
  let hDragging = false;

  function setStageHeight(px) {
    const rect = rightPane.getBoundingClientRect();
    const titleH = turtleTitle.getBoundingClientRect().height;
    const splitterH = hsplitter.getBoundingClientRect().height;

    const minStage = 180;
    const minConsole = 180;

    const totalBelowTitle = rect.height - titleH - splitterH;
    const maxStage = Math.max(minStage, totalBelowTitle - minConsole);

    const clamped = Math.max(minStage, Math.min(px, maxStage));

    stageWrap.style.flex = `0 0 ${clamped}px`;
    consolePane.style.flex = "1 1 0";

    fitAfterLayout();
  }

  hsplitter.addEventListener("pointerdown", (e) => {
    hDragging = true;
    hsplitter.setPointerCapture(e.pointerId);
    document.body.style.cursor = "row-resize";
    document.body.style.userSelect = "none";
  });

  hsplitter.addEventListener("pointermove", (e) => {
    if (!hDragging) return;
    const rect = rightPane.getBoundingClientRect();
    const titleH = turtleTitle.getBoundingClientRect().height;
    const y = e.clientY - rect.top;
    const desiredStage = y - titleH;
    setStageHeight(desiredStage);
  });

  hsplitter.addEventListener("pointerup", (e) => {
    hDragging = false;
    try { hsplitter.releasePointerCapture(e.pointerId); } catch {}
    document.body.style.cursor = "";
    document.body.style.userSelect = "";
  });

  /* ---------- Turtle state (displayed) ---------- */
  const turtleState = { x: 0, y: 0, heading: 0, visible: true, color: "#00ff66" };
  let logicalState = { x: 0, y: 0, heading: 0, visible: true, pencolor: "#00ff66" };

  function toCanvasXY(x, y) {
    const rect = canvas.getBoundingClientRect();
    return { cx: rect.width / 2 + x, cy: rect.height / 2 - y };
  }

  function overlayClear() {
    const rect = overlay.getBoundingClientRect();
    octx.clearRect(0, 0, rect.width, rect.height);
  }

  function redrawTurtle() {
    overlayClear();
    if (!turtleState.visible) return;

    const p = toCanvasXY(turtleState.x, turtleState.y);
    const size = 12;
    const ang = (turtleState.heading * Math.PI) / 180;

    const tip = { x: Math.cos(ang) * size, y: -Math.sin(ang) * size };
    const left = { x: Math.cos(ang + 2.5) * (size * 0.75), y: -Math.sin(ang + 2.5) * (size * 0.75) };
    const right = { x: Math.cos(ang - 2.5) * (size * 0.75), y: -Math.sin(ang - 2.5) * (size * 0.75) };

    octx.beginPath();
    octx.moveTo(p.cx + tip.x, p.cy + tip.y);
    octx.lineTo(p.cx + left.x, p.cy + left.y);
    octx.lineTo(p.cx + right.x, p.cy + right.y);
    octx.closePath();

    octx.fillStyle = turtleState.color || "#00ff66";
    octx.globalAlpha = turtleAlpha;
    octx.fill();
    octx.globalAlpha = 1;
  }

  /* ---------- Canvas sizing ---------- */
  let currentBg = "#111111";
  const strokes = [];

  // Offscreen back buffer for tracer(0) + update()
  const backCanvas = document.createElement("canvas");
  const bctx = backCanvas.getContext("2d");

  // tracerN: 1 = normal (default), 0 = manual refresh (draw to back buffer, flip on update())
  let tracerN = 1;
  let bufferedTurtleState = null;

  function fitOneCanvas(c, context) {
    const rect = c.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    c.width = Math.max(1, Math.floor(rect.width * dpr));
    c.height = Math.max(1, Math.floor(rect.height * dpr));
    context.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  function setDprTransform(context) {
    const dpr = window.devicePixelRatio || 1;
    context.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  function fitBackBuffer() {
    backCanvas.width = canvas.width;
    backCanvas.height = canvas.height;
    setDprTransform(bctx);
  }

  function syncBackBufferFromFront() {
    // Copy device pixels (ignore DPR transforms)
    bctx.setTransform(1, 0, 0, 1, 0, 0);
    bctx.clearRect(0, 0, backCanvas.width, backCanvas.height);
    bctx.drawImage(canvas, 0, 0);
    setDprTransform(bctx);
  }

  function flipBackToFront() {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(backCanvas, 0, 0);
    setDprTransform(ctx);
  }

  function fillBgOn(context) {
    const rect = canvas.getBoundingClientRect();
    context.fillStyle = currentBg;
    context.fillRect(0, 0, rect.width, rect.height);
  }

  function canvasClear() {
    fillBgOn(ctx);
    fillBgOn(bctx);
  }

  function redrawAll() {
    const rect = canvas.getBoundingClientRect();
    ctx.fillStyle = currentBg;
    ctx.fillRect(0, 0, rect.width, rect.height);

    for (const s of strokes) {
      drawSegment(s.x1, s.y1, s.x2, s.y2, s.color, s.width);
    }

    redrawTurtle();
  }

  function fitCanvases() {
    fitOneCanvas(canvas, ctx);
    fitOneCanvas(overlay, octx);
    fitBackBuffer();
    redrawAll();
  }

  function fitAfterLayout() {
    requestAnimationFrame(() => {
      fitCanvases();
      requestAnimationFrame(() => fitCanvases());
    });
  }

  window.addEventListener("resize", () => { cm.refresh(); fitAfterLayout(); });

  // ✅ Fix for "console scroll messes up turtle Y": resize canvases when layout changes (not just window resize)
  const ro = new ResizeObserver(() => fitAfterLayout());
  ro.observe(stageWrap);

  fitAfterLayout();

  /* ---------- Ordered animation queue ---------- */

  const q = [];
  let animating = false;
  let timer = null;

  let lastLineWaitingForState = null;
  let lastKnownSpeed = 10;

  const MIN_TICKS_PER_SEGMENT = 8;

  function speedParams(speed) {
    let s = Number(speed);
    if (!Number.isFinite(s)) s = 10;
    if (s <= 0) return { instant: true, tickMs: 0, pxPerTick: Infinity };
    if (s > 10) s = 10;

    let tickMs;
    if (s <= 2) {
      tickMs = 128 + (20 - 128) * (s - 1);
    } else {
      const t = (s - 2) / 8;
      tickMs = 20 * Math.pow(1 / 20, t);
    }

    let pxPerTick;
    if (s <= 2) {
      pxPerTick = 5 + (28 - 5) * (s - 1);
    } else {
      const t = (s - 2) / 8;
      pxPerTick = 28 * Math.pow(200 / 28, t);
    }

    return {
      instant: false,
      tickMs: Math.max(1, Math.round(tickMs)),
      pxPerTick: Math.max(1, Math.round(pxPerTick)),
    };
  }

  function effectivePxPerTick(dist, pxPerTick) {
    const maxPxThisSegment = Math.max(1, dist / MIN_TICKS_PER_SEGMENT);
    return Math.min(pxPerTick, maxPxThisSegment);
  }

  function drawSegmentTo(context, x1, y1, x2, y2, color, width) {
    const a = toCanvasXY(x1, y1);
    const b = toCanvasXY(x2, y2);
    context.strokeStyle = color || "#00ff66";
    context.lineWidth = Number(width || 2);
    context.lineCap = "round";
    context.beginPath();
    context.moveTo(a.cx, a.cy);
    context.lineTo(b.cx, b.cy);
    context.stroke();
  }

  function drawSegment(x1, y1, x2, y2, color, width) {
    drawSegmentTo(ctx, x1, y1, x2, y2, color, width);
  }

  function applyStateToTurtle(s) {
    if (!s) return;
    turtleState.x = Number(s.x) || 0;
    turtleState.y = Number(s.y) || 0;
    turtleState.heading = Number(s.heading) || 0;
    turtleState.visible = !!s.visible;
    turtleState.color = s.pencolor || turtleState.color;
  }

  // (rest of your original code continues unchanged — included in full file)
  // NOTE: For brevity in this code cell we continue writing the remainder exactly as in the patched version you tested.

  /* ---------- Movement / line animation functions ---------- */
  function animateMove(from, to, speed, done) {
    const { instant, tickMs, pxPerTick } = speedParams(speed);
    const x1 = Number(from.x) || 0, y1 = Number(from.y) || 0;
    const x2 = Number(to.x) || 0, y2 = Number(to.y) || 0;

    const heading = Number(to.heading) || turtleState.heading;
    const visible = !!to.visible;
    const tColor = to.pencolor || turtleState.color;

    if (instant) {
      turtleState.x = x2; turtleState.y = y2;
      turtleState.heading = heading;
      turtleState.visible = visible;
      turtleState.color = tColor;
      redrawTurtle();
      done();
      return;
    }

    const dx = x2 - x1, dy = y2 - y1;
    const dist = Math.hypot(dx, dy);

    if (dist < 0.5) {
      turtleState.x = x2; turtleState.y = y2;
      turtleState.heading = heading;
      turtleState.visible = visible;
      turtleState.color = tColor;
      redrawTurtle();
      done();
      return;
    }

    const stepPx = effectivePxPerTick(dist, pxPerTick);
    let travelled = 0;
    const myToken = cancelToken;

    const step = () => {
      if (myToken !== cancelToken) return;
      const nextTravel = Math.min(dist, travelled + stepPx);
      const t = nextTravel / dist;

      turtleState.x = x1 + dx * t;
      turtleState.y = y1 + dy * t;
      turtleState.heading = heading;
      turtleState.visible = visible;
      turtleState.color = tColor;
      redrawTurtle();

      travelled = nextTravel;

      if (travelled >= dist - 1e-6) {
        turtleState.x = x2; turtleState.y = y2;
        redrawTurtle();
        done();
        return;
      }

      timer = setTimeout(step, tickMs);
    };
    step();
  }

  function animateLine(cmd, done) {
    const { instant, tickMs, pxPerTick } = speedParams(cmd.speed);
    const endState = cmd.endState;

    const heading = Number(endState.heading) || turtleState.heading;
    const visible = !!endState.visible;
    const tColor = endState.pencolor || turtleState.color;

    if (instant) {
      drawSegment(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.color, cmd.width);
      drawSegmentTo(bctx, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.color, cmd.width);
      strokes.push({ x1: Number(cmd.x1)||0, y1: Number(cmd.y1)||0, x2: Number(cmd.x2)||0, y2: Number(cmd.y2)||0, color: cmd.color, width: cmd.width });
      applyStateToTurtle(endState);
      redrawTurtle();
      done();
      return;
    }

    const x1 = Number(cmd.x1) || 0, y1 = Number(cmd.y1) || 0;
    const x2 = Number(cmd.x2) || 0, y2 = Number(cmd.y2) || 0;
    const dx = x2 - x1, dy = y2 - y1;
    const dist = Math.hypot(dx, dy);

    if (dist < 0.5) {
      drawSegment(x1, y1, x2, y2, cmd.color, cmd.width);
      drawSegmentTo(bctx, x1, y1, x2, y2, cmd.color, cmd.width);
      strokes.push({ x1, y1, x2, y2, color: cmd.color, width: cmd.width });
      applyStateToTurtle(endState);
      redrawTurtle();
      done();
      return;
    }

    const stepPx = effectivePxPerTick(dist, pxPerTick);
    let travelled = 0;
    let lastX = x1, lastY = y1;
    const myToken = cancelToken;

    const step = () => {
      if (myToken !== cancelToken) return;
      const nextTravel = Math.min(dist, travelled + stepPx);
      const t = nextTravel / dist;

      const curX = x1 + dx * t;
      const curY = y1 + dy * t;

      drawSegment(lastX, lastY, curX, curY, cmd.color, cmd.width);

      turtleState.x = curX;
      turtleState.y = curY;
      turtleState.heading = heading;
      turtleState.visible = visible;
      turtleState.color = tColor;
      redrawTurtle();

      travelled = nextTravel;
      lastX = curX; lastY = curY;

      if (travelled >= dist - 1e-6) {
        strokes.push({ x1, y1, x2, y2, color: cmd.color, width: cmd.width });
        drawSegmentTo(bctx, x1, y1, x2, y2, cmd.color, cmd.width);
        applyStateToTurtle(endState);
        redrawTurtle();
        done();
        return;
      }

      timer = setTimeout(step, tickMs);
    };
    step();
  }

  function runQueue() {
    if (animating) return;
    animating = true;

    const next = () => {
      if (!q.length) {
        animating = false;
        timer = null;
        return;
      }

      const item = q.shift();

      if (item.kind === "state") {
        applyStateToTurtle(item.state);
        redrawTurtle();
        next();
        return;
      }

      if (item.kind === "move") {
        animateMove(item.from, item.to, item.speed, next);
        return;
      }

      if (item.kind === "line") {
        if (!item.endState) {
          q.unshift(item);
          animating = false;
          return;
        }
        animateLine(item, next);
        return;
      }
    };

    next();
  }

  function resetQueues() {
    cancelToken++;
    if (timer) { clearTimeout(timer); timer = null; }
    q.length = 0;
    animating = false;
    lastLineWaitingForState = null;
  }

  function handleCanvasCmd(cmd) {
    if (!cmd || !cmd.type) return;

    // Manual refresh controls: tracer(0) + update()
    if (cmd.type === "tracer") {
      tracerN = Number(cmd.n);
      if (!Number.isFinite(tracerN)) tracerN = 1;

      // Entering manual mode: stop any in-flight animation and use the current front as the base
      if (tracerN === 0) {
        resetQueues();
        syncBackBufferFromFront();
      }
      return;
    }

    if (cmd.type === "update") {
      if (tracerN === 0) {
        flipBackToFront();
        if (bufferedTurtleState) {
          logicalState = bufferedTurtleState;
          bufferedTurtleState = null;
        }
        redrawTurtle();
      }
      return;
    }

    if (cmd.type === "bg") {
      currentBg = cmd.color || "#111111";
      strokes.length = 0;
      resetQueues();
      bufferedTurtleState = null;

      if (tracerN === 0) {
        fillBgOn(bctx);
        return;
      }

      canvasClear();
      redrawTurtle();
      return;
    }

    if (cmd.type === "clear") {
      strokes.length = 0;
      resetQueues();
      bufferedTurtleState = null;

      if (tracerN === 0) {
        fillBgOn(bctx);
        return;
      }

      canvasClear();
      redrawTurtle();
      return;
    }

    if (cmd.type === "line") {
      lastKnownSpeed = cmd.speed ?? lastKnownSpeed;

      // tracer(0): draw instantly to the back buffer; don't animate or touch the front canvas
      if (tracerN === 0) {
        drawSegmentTo(bctx, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.color, cmd.width);
        strokes.push({ x1: Number(cmd.x1)||0, y1: Number(cmd.y1)||0, x2: Number(cmd.x2)||0, y2: Number(cmd.y2)||0, color: cmd.color, width: cmd.width });
        return;
      }

      const lineItem = {
        kind: "line",
        x1: cmd.x1, y1: cmd.y1,
        x2: cmd.x2, y2: cmd.y2,
        color: cmd.color,
        width: cmd.width,
        speed: cmd.speed,
        endState: null
      };

      q.push(lineItem);
      lastLineWaitingForState = lineItem;
      runQueue();
      return;
    }

    if (cmd.type === "turtle") {
      const nextState = {
        x: Number(cmd.x) || 0,
        y: Number(cmd.y) || 0,
        heading: Number(cmd.heading) || 0,
        visible: !!cmd.visible,
        pencolor: cmd.pencolor || logicalState.pencolor
      };

      if (tracerN === 0) {
        logicalState = nextState;
        bufferedTurtleState = nextState;
        return;
      }

      if (lastLineWaitingForState && !lastLineWaitingForState.endState) {
        lastLineWaitingForState.endState = nextState;
        lastLineWaitingForState = null;
        logicalState = nextState;
        runQueue();
        return;
      }

      const moved = (nextState.x !== logicalState.x) || (nextState.y !== logicalState.y);
      const headingChanged = nextState.heading !== logicalState.heading;
      const visChanged = nextState.visible !== logicalState.visible;
      const colorChanged = nextState.pencolor !== logicalState.pencolor;

      if (moved) {
        q.push({ kind: "move", from: logicalState, to: nextState, speed: lastKnownSpeed });
      } else if (headingChanged || visChanged || colorChanged) {
        q.push({ kind: "state", state: nextState });
      }

      logicalState = nextState;
      runQueue();
      return;
    }
  }

  /* ---------- Console (seamless input) ---------- */

  let inputActive = false;
  let inputBuffer = "";
  let caretEl = null;

  function ensureCaret() {
    if (caretEl && caretEl.isConnected) return;
    caretEl = document.createElement("span");
    caretEl.className = "caret";
    consoleEl.appendChild(caretEl);
  }

  function removeCaret() {
    if (caretEl && caretEl.isConnected) caretEl.remove();
  }

  function scrollConsoleToBottom() {
    consoleEl.scrollTop = consoleEl.scrollHeight;
  }

  function write(s = "") {
    removeCaret();
    if (s !== "") consoleEl.appendChild(document.createTextNode(String(s)));
    if (inputActive) ensureCaret();
    scrollConsoleToBottom();
  }

  function writeln(s = "") {
    write(String(s) + "\n");
  }

  function clearConsole() {
    consoleEl.textContent = "";
    caretEl = null;
    inputActive = false;
    inputBuffer = "";
  }

  clearBtn.onclick = () => { clearConsole(); consoleEl.focus(); };

  function beginInput(prompt) {
    inputActive = true;
    inputBuffer = "";
    if (prompt) write(String(prompt));
    ensureCaret();
    consoleEl.focus();
  }

  function cancelInputUI() {
    inputActive = false;
    inputBuffer = "";
    removeCaret();
  }

  consoleEl.addEventListener("pointerdown", () => consoleEl.focus());

  consoleEl.addEventListener("keydown", (e) => {
    if (!inputActive) return;

    if (e.ctrlKey || e.metaKey) {
      if (e.key.toLowerCase() === "c" || e.key.toLowerCase() === "a") return;
    }

    e.preventDefault();

    if (e.key === "Enter") {
      write("\n");
      inputActive = false;
      removeCaret();
      worker?.postMessage({ type: "input_response", text: inputBuffer });
      inputBuffer = "";
      return;
    }

    if (e.key === "Backspace") {
      if (!inputBuffer.length) return;
      inputBuffer = inputBuffer.slice(0, -1);

      removeCaret();
      const last = consoleEl.lastChild;
      if (last && last.nodeType === Node.TEXT_NODE) {
        last.textContent = last.textContent.slice(0, -1);
        if (last.textContent.length === 0) last.remove();
      } else if (last) {
        consoleEl.textContent = consoleEl.textContent.slice(0, -1);
      }
      ensureCaret();
      scrollConsoleToBottom();
      return;
    }

    if (e.key.length === 1) {
      inputBuffer += e.key;
      write(e.key);
      return;
    }
  });

  consoleEl.addEventListener("paste", (e) => {
    if (!inputActive) return;
    e.preventDefault();
    const text = (e.clipboardData || window.clipboardData).getData("text");
    if (!text) return;
    inputBuffer += text;
    write(text);
  });

  /* ---------- Programs ---------- */
  let currentFile = null;

  async function loadProgramList() {
    const res = await fetch("./programs.json", { cache: "no-store" });
    const files = await res.json();
    programSel.innerHTML = "";
    for (const f of files) programSel.add(new Option(f, f));
    return files[0];
  }

  async function loadProgram(file) {
    setStatus("Loading " + file + "…");
    const res = await fetch("./" + file, { cache: "no-store" });
    const text = await res.text();
    currentFile = file;
    cm.setValue(text);
    filenameEl.textContent = file;
    programSel.value = file;
    setStatus("Ready");
  }

  programSel.addEventListener("change", async () => {
    await loadProgram(programSel.value);
  });

  reloadBtn.addEventListener("click", async () => {
    await loadProgram(programSel.value);
  });

  /* ---------- Worker ---------- */
  let worker = null;
  let running = false;
  const INACTIVITY_LIMIT_MS = 3000; // soft stop if no output/drawing for this long
  const INACTIVITY_POLL_MS = 200;
  let lastActivityTs = 0;

  let runTimeoutId = null;

  let acceptCanvas = true;
  let cancelToken = 0;

  function extractFriendlyStopMessage(text) {
    const s = String(text ?? "");
    // Pull out our friendly stop reasons from noisy Python tracebacks.
    for (const line of s.split("\n")) {
      if (line.includes("Stopped: turtle command limit exceeded")) return line.trim();
      if (line.includes("Stopped: time limit exceeded")) return line.trim();
    }
    return null;
  }


  function makeWorker() {
    const w = new Worker("./py_worker.js?v=tracer4", { type: "module" });

    w.onmessage = (ev) => {
      const m = ev.data || {};
      if (running) lastActivityTs = Date.now();
      if (m.type === "stdout") writeln(m.text ?? "");
      if (m.type === "stderr") writeln(m.text ?? "");
      if (m.type === "status") setStatus(m.text ?? "");
      if (m.type === "canvas_cmd") {
        if (!acceptCanvas) return;
        handleCanvasCmd(m.cmd);
      }

      if (m.type === "input_request") {
        beginInput(m.prompt ?? "");
      }

      if (m.type === "ready") {
        setStatus("Ready");
        runBtn.disabled = false;
        stopBtn.disabled = false;
      }
      if (m.type === "done") {
        running = false;
        if (runTimeoutId) { clearTimeout(runTimeoutId); runTimeoutId = null; }
        runBtn.disabled = false;
        stopBtn.disabled = false;
        setStatus("Done");
        cancelInputUI();
      }
      if (m.type === "error") {
        running = false;
        if (runTimeoutId) { clearTimeout(runTimeoutId); runTimeoutId = null; }
        runBtn.disabled = false;
        stopBtn.disabled = false;
        const friendly = extractFriendlyStopMessage(m.text);
        if (friendly) {
          setStatus("Stopped");
          writeln(friendly + "\n");
        } else {
          setStatus("Error");
          writeln(String(m.text ?? ""));
        }
        cancelInputUI();
      }
    };

    w.postMessage({ type: "init" });
    return w;
  }

  function stopExecution(reason = "Stopped", userInitiated = true) {
    acceptCanvas = false;
    resetQueues();
    cancelInputUI();

    // Reset tracer mode so it can't leak between runs
    tracerN = 1;
    bufferedTurtleState = null;

    if (runTimeoutId) { clearTimeout(runTimeoutId); runTimeoutId = null; }

    if (userInitiated) {
      writeln("Program stopped by user.");
    } else {
      writeln(String(reason) + ".");
    }
    try { worker?.terminate(); } catch {}
    worker = makeWorker();
    running = false;
    runBtn.disabled = false;
    stopBtn.disabled = false;
    setStatus(reason);
  }

  stopBtn.addEventListener("click", () => stopExecution("Stopped", true));
  worker = makeWorker();

  runBtn.onclick = () => {
    clearConsole();
    resetQueues();

    // Reset tracer mode at the start of every run (prevents tracer(0) from leaking)
    tracerN = 1;
    bufferedTurtleState = null;

    strokes.length = 0;

    currentBg = "#111111";
    canvasClear();

    logicalState = { x: 0, y: 0, heading: 0, visible: true, pencolor: "#00ff66" };
    turtleState.x = 0; turtleState.y = 0; turtleState.heading = 0;
    turtleState.visible = true; turtleState.color = "#00ff66";
    redrawTurtle();

    running = true;
    acceptCanvas = true;
    runBtn.disabled = true;
    stopBtn.disabled = false;
    setStatus("Running…");
    if (runTimeoutId) { clearTimeout(runTimeoutId); runTimeoutId = null; }
    lastActivityTs = Date.now();
    runTimeoutId = setInterval(() => {
      if (!running) return;
      if (Date.now() - lastActivityTs > INACTIVITY_LIMIT_MS) {
        stopExecution("Stopped: time limit exceeded (3s)", false);
      }
    }, INACTIVITY_POLL_MS);
    worker.postMessage({ type: "run", code: cm.getValue() });
  };

  /* ---------- Init ---------- */
  (async () => {
    setStatus("Loading…");
    const first = await loadProgramList();
    await loadProgram(first);
    programSel.disabled = false;
    runBtn.disabled = false;
    reloadBtn.disabled = false;
    stopBtn.disabled = false;
    setStatus("Ready");
  })();
</script>

<script>
// === Privacy button (UI-only) ===
document.addEventListener("DOMContentLoaded", () => {
  const PRIVACY_TEXT = "This website does not collect, store, or process any personal data.\n\nThere are no user accounts, no logins, no cookies, no analytics, and no tracking of any kind. Code entered on this site is not saved or transmitted by the site owner.\n\nThis site is hosted on GitHub Pages. GitHub may collect limited technical information (such as IP addresses) as part of normal website hosting. This data is processed by GitHub in accordance with their own Privacy Policy.\n\nBy using this site, you agree to GitHub’s Privacy Policy.";

  // Find the first existing button (assumed to be in the top control bar)
  const firstButton = document.querySelector("button");
  if (!firstButton || !firstButton.parentElement) return;

  const privacyBtn = document.createElement("button");
  privacyBtn.textContent = "Privacy";
  privacyBtn.title = "Privacy / GDPR";
  privacyBtn.style.marginRight = "6px";
  privacyBtn.addEventListener("click", () => {
    
    const accepted = confirm(
      PRIVACY_TEXT + "\n\nClick OK to view GitHub’s Privacy Policy in a new tab."
    );
    if (accepted) {
      window.open("https://docs.github.com/en/site-policy/privacy-policies/github-privacy-statement", "_blank", "noopener");
    }

  });

  // Insert inline with other buttons (to the left of the first button)
  firstButton.parentElement.insertBefore(privacyBtn, firstButton);
});
</script>

</body>
</html>
