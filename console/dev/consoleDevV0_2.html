<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Python Runner (Editor + Console)</title>

  <!-- CodeMirror 5 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/lib/codemirror.css">
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/lib/codemirror.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/mode/python/python.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/addon/edit/matchbrackets.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/addon/comment/comment.js"></script>

  <style>
    body { margin: 0; height: 100vh; display: flex; flex-direction: column; font-family: system-ui, sans-serif; }
    header { display: flex; gap: 10px; align-items: center; padding: 10px 12px; border-bottom: 1px solid #ddd; }
    #status { color: #666; font-size: 14px; }
    .spacer { flex: 1; }
    button { padding: 6px 12px; cursor: pointer; }
    select { padding: 6px 10px; border: 1px solid #ccc; border-radius: 8px; background: white; font-size: 14px; }

    #app { flex: 1; display: flex; min-height: 0; width: 100%; }
    #left, #right { display: flex; flex-direction: column; min-height: 0; flex: 1 1 0; min-width: 220px; }

    .pane-title {
      padding: 6px 12px;
      font-size: 14px;
      color: #444;
      border-bottom: 1px solid #eee;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .pane-title .spacer { flex: 1; }

    #splitter {
      width: 8px;
      cursor: col-resize;
      background: #f3f3f3;
      border-left: 1px solid #ddd;
      border-right: 1px solid #ddd;
      flex: 0 0 8px;
      user-select: none;
      touch-action: none;
    }
    #splitter:hover { background: #e9e9e9; }

    #editorWrap { flex: 1; min-height: 0; }
    .CodeMirror { height: 100% !important; font-size: 14px; line-height: 1.4; }
    .CodeMirror-gutters { border-right: 1px solid #eee; }

    #consoleWrap { flex: 1; min-height: 0; background: #0b0b0b; }
    #console {
      height: 100%;
      padding: 12px;
      overflow: auto;
      color: #eaeaea;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 14px;
      line-height: 1.4;
      white-space: pre-wrap;
      outline: none;
      cursor: text;
      background: #0b0b0b;
      box-sizing: border-box;
      min-height: 0;
    }

    .caret {
      display: inline-block;
      width: 8px;
      margin-left: 1px;
      background: #eaeaea;
      animation: blink 1s steps(1) infinite;
      height: 1em;
    }
    @keyframes blink { 50% { opacity: 0; } }
  </style>
</head>

<body>
<header>
  <label style="font-size:14px;color:#444;">Dev v0.2 - Program:</label>
  <select id="program" disabled></select>

  <button id="privacy">Privacy</button>

  <button id="run" disabled>Run ▶</button>
  <button id="stop" disabled>Stop ■</button>
  <button id="reload" disabled>Reload ↻</button>

  <button id="newFile" disabled>New…</button>
  <button id="save" disabled>Save</button>
  <button id="saveAs" disabled>Save As…</button>
  <button id="upload" disabled>Upload</button>

  <div class="spacer"></div>
  <div id="status">Loading…</div>
</header>

<div id="app">
  <section id="left">
    <div class="pane-title" id="filename">Editor</div>
    <div id="editorWrap"><textarea id="editor"></textarea></div>
  </section>

  <div id="splitter" title="Drag to resize"></div>

  <section id="right">
    <div class="pane-title">
      <span>Console</span>
      <div class="spacer"></div>
      <button id="clear" disabled>Clear console</button>
    </div>
    <div id="consoleWrap">
      <div id="console" tabindex="0"></div>
    </div>
  </section>
</div>

<input id="fileInput" type="file" accept=".txt,.py" style="display:none" />

<script type="module">
  const runBtn = document.getElementById("run");
  const stopBtn = document.getElementById("stop");
  const reloadBtn = document.getElementById("reload");
  const newBtn = document.getElementById("newFile");
  const saveBtn = document.getElementById("save");
  const saveAsBtn = document.getElementById("saveAs");
  const uploadBtn = document.getElementById("upload");
  const clearBtn = document.getElementById("clear");
  const privacyBtn = document.getElementById("privacy");

  const statusEl = document.getElementById("status");
  const programSel = document.getElementById("program");
  const filenameEl = document.getElementById("filename");
  const consoleEl = document.getElementById("console");
  const fileInput = document.getElementById("fileInput");

  const leftPane = document.getElementById("left");
  const rightPane = document.getElementById("right");
  const splitter = document.getElementById("splitter");
  const app = document.getElementById("app");

  const setStatus = (s) => statusEl.textContent = s;

  // Privacy / GDPR
  const PRIVACY_TEXT = "This website does not collect, store, or process any personal data.

There are no user accounts, no logins, no cookies, no analytics, and no tracking of any kind. Code entered on this site is not saved or transmitted by the site owner.

This site is hosted on GitHub Pages. GitHub may collect limited technical information (such as IP addresses) as part of normal website hosting. This data is processed by GitHub in accordance with their own Privacy Policy.

By using this site, you agree to GitHub’s Privacy Policy.";
  const GITHUB_PRIVACY_URL = "https://docs.github.com/en/site-policy/privacy-policies/github-privacy-statement";
  privacyBtn?.addEventListener("click", () => {
    const accepted = confirm(PRIVACY_TEXT + "

Click OK to view GitHub’s Privacy Policy in a new tab.");
    if (accepted) window.open(GITHUB_PRIVACY_URL, "_blank", "noopener");
  });

  /* ---------- Console helpers ---------- */
  function scrollConsole() { consoleEl.scrollTop = consoleEl.scrollHeight; }
  function removeCaret() { consoleEl.querySelector(".caret")?.remove(); }
  function renderCaret() {
    removeCaret();
    const c = document.createElement("span");
    c.className = "caret";
    consoleEl.appendChild(c);
  }
  function write(s="") {
    removeCaret();
    consoleEl.textContent += s;
    if (inputActive) renderCaret();
    scrollConsole();
  }
  function writeln(s="") { write(s + "\n"); }
  function clearConsole() { consoleEl.textContent = ""; }

  clearBtn.onclick = () => { clearConsole(); consoleEl.focus(); };

  /* ---------- Editor ---------- */
  const cm = CodeMirror.fromTextArea(document.getElementById("editor"), {
    mode: "python",
    lineNumbers: true,
    indentUnit: 4,
    tabSize: 4,
    smartIndent: true,
    matchBrackets: true,
    extraKeys: {
      "Tab": cm => cm.replaceSelection("    ", "end"),
      "Shift-Tab": cm => cm.indentSelection("subtract")
    }
  });
  cm.setSize(null, "100%");

  /* ---------- Splitter ---------- */
  let dragging = false;
  function setLeftWidth(px) {
    const total = app.getBoundingClientRect().width;
    const minLeft = 220;
    const minRight = 220;
    const maxLeft = total - 8 - minRight;
    const clamped = Math.max(minLeft, Math.min(px, maxLeft));
    leftPane.style.flex = `0 0 ${clamped}px`;
    rightPane.style.flex = `1 1 0`;
    cm.refresh();
  }
  splitter.addEventListener("pointerdown", (e) => {
    dragging = true;
    splitter.setPointerCapture(e.pointerId);
    document.body.style.cursor = "col-resize";
    document.body.style.userSelect = "none";
  });
  splitter.addEventListener("pointermove", (e) => {
    if (!dragging) return;
    const rect = app.getBoundingClientRect();
    setLeftWidth(e.clientX - rect.left);
  });
  splitter.addEventListener("pointerup", (e) => {
    dragging = false;
    try { splitter.releasePointerCapture(e.pointerId); } catch {}
    document.body.style.cursor = "";
    document.body.style.userSelect = "";
  });
  window.addEventListener("resize", () => cm.refresh());

  /* ---------- Inline input (UI side) ---------- */
  let inputActive = false;
  let inputBuffer = "";
  let waitingForInput = false;

  function beginInput(prompt) {
    inputActive = true;
    inputBuffer = "";
    waitingForInput = true;
    if (prompt) write(String(prompt));
    renderCaret();
    consoleEl.focus();
  }

  function cancelInputIfAny() {
    if (!waitingForInput) return;
    inputActive = false;
    waitingForInput = false;
    removeCaret();
    worker?.postMessage({ type: "input_response", text: "" });
  }

  consoleEl.addEventListener("keydown", (e) => {
    if (!inputActive) return;
    e.preventDefault();

    if (e.key === "Enter") {
      write("\n");
      inputActive = false;
      waitingForInput = false;
      removeCaret();
      worker?.postMessage({ type: "input_response", text: inputBuffer });
    } else if (e.key === "Backspace") {
      if (inputBuffer.length) {
        inputBuffer = inputBuffer.slice(0, -1);
        removeCaret();
        consoleEl.textContent = consoleEl.textContent.slice(0, -1);
        renderCaret();
      }
    } else if (e.key.length === 1) {
      inputBuffer += e.key;
      write(e.key);
    }
  });
  consoleEl.addEventListener("mousedown", () => consoleEl.focus());

  /* ---------- Program state ---------- */
  let currentFile = null;
  let previousSelectValue = null;

  const originals = new Map();
  const uploadedText = new Map();
  const fileHandles = new Map();

  const hasFS = ("showOpenFilePicker" in window) && ("showSaveFilePicker" in window);

  function getEditorText() { return cm.getValue().replace(/\r\n/g, "\n"); }
  function getOriginalText(file) { return (originals.get(file) ?? "").replace(/\r\n/g, "\n"); }
  function isDirtyAgainstOriginal() { return !!currentFile && getEditorText() !== getOriginalText(currentFile); }

  function confirmDiscardIfDirty(actionName) {
    if (!isDirtyAgainstOriginal()) return true;
    return confirm(`${actionName} will discard your changes to "${currentFile}".\n\nAre you sure?`);
  }

  function ensureOptionExists(name) {
    const exists = Array.from(programSel.options).some(o => o.value === name);
    if (!exists) programSel.add(new Option(name, name));
  }

  function setSaveButtons() {
    const canSave = !!(currentFile && fileHandles.has(currentFile) && isDirtyAgainstOriginal());
    saveBtn.disabled = !canSave;
    saveAsBtn.disabled = false;
  }
  cm.on("change", () => setSaveButtons());

  async function loadProgramList() {
    const res = await fetch("./programs.json", { cache: "no-store" });
    const files = await res.json();
    programSel.innerHTML = "";
    for (const f of files) programSel.add(new Option(f, f));
    return files[0];
  }

  async function readFromHandle(handle) {
    const f = await handle.getFile();
    return await f.text();
  }

  /* ---------- Worker run control ---------- */
  let worker = null;
  let running = false;

  function makeWorker() {
    const w = new Worker("./py_worker.js", { type: "module" });
    w.onmessage = (ev) => {
      const m = ev.data || {};
      if (m.type === "stdout") writeln(m.text ?? "");
      if (m.type === "stderr") writeln(m.text ?? "");
      if (m.type === "status") setStatus(m.text ?? "");
      if (m.type === "ready") {
        setStatus("Ready");
        runBtn.disabled = false;
        stopBtn.disabled = true;
      }
      if (m.type === "done") {
        running = false;
        runBtn.disabled = false;
        stopBtn.disabled = true;
        setStatus("Done");
      }
      if (m.type === "error") {
        running = false;
        runBtn.disabled = false;
        stopBtn.disabled = true;
        setStatus("Error");
        writeln(String(m.text ?? ""));
      }
      if (m.type === "input_request") {
        beginInput(m.prompt ?? "");
      }
    };
    w.postMessage({ type: "init" });
    return w;
  }

  function stopExecution(reason = "Stopped") {
    if (running || waitingForInput) {
      cancelInputIfAny();
      writeln("\nProgram stopped by user.");
      try { worker?.terminate(); } catch {}
      worker = makeWorker();
      running = false;
      runBtn.disabled = false;
      stopBtn.disabled = true;
      setStatus(reason);
    }
  }

  // Stop button
  stopBtn.addEventListener("click", () => stopExecution("Stopped"));

  // start worker immediately
  worker = makeWorker();

  async function loadProgram(file) {
    stopExecution("Stopped");

    removeCaret();
    clearConsole();
    setStatus("Loading " + file + "…");

    let text;
    if (fileHandles.has(file)) {
      text = await readFromHandle(fileHandles.get(file));
      uploadedText.set(file, text);
      originals.set(file, text);
    } else if (uploadedText.has(file)) {
      text = uploadedText.get(file);
      originals.set(file, text);
    } else {
      const res = await fetch("./" + file, { cache: "no-store" });
      text = await res.text();
      originals.set(file, text);
    }

    currentFile = file;
    cm.setValue(text);
    filenameEl.textContent = file;

    programSel.value = file;
    previousSelectValue = file;

    if (uploadedText.has(file)) setStatus(fileHandles.has(file) ? "Ready (opened)" : "Ready (uploaded)");
    else setStatus("Ready");

    setSaveButtons();
    consoleEl.focus();
  }

  programSel.addEventListener("change", async () => {
    const nextFile = programSel.value;
    if (!confirmDiscardIfDirty("Switching programs")) {
      programSel.value = previousSelectValue ?? currentFile ?? nextFile;
      return;
    }
    await loadProgram(nextFile);
  });

  reloadBtn.addEventListener("click", async () => {
    if (!confirmDiscardIfDirty("Reloading")) return;
    await loadProgram(programSel.value);
  });

  function normaliseNewName(name) {
    const trimmed = (name || "").trim();
    if (!trimmed) return null;
    const cleaned = trimmed.replace(/[\\\/:*?"<>|]/g, "_");
    if (/\.(py|txt)$/i.test(cleaned)) return cleaned.replace(/\.(py|txt)$/i, ".py");
    return cleaned + ".py";
  }

  newBtn.addEventListener("click", async () => {
    if (!confirmDiscardIfDirty("Creating a new file")) return;
    stopExecution("Stopped");

    const entered = prompt("New file name (e.g. my_program):", "my_program");
    if (entered === null) return;
    const newName = normaliseNewName(entered);
    if (!newName) return;

    ensureOptionExists(newName);
    uploadedText.set(newName, "");
    originals.set(newName, "");
    fileHandles.delete(newName);

    await loadProgram(newName);
    setStatus("Ready (new)");
    setSaveButtons();
  });

  /* ---------- Save / Save As (same as before) ---------- */
  function suggestedTxtNameFromCurrent() {
    const base = (currentFile || "program").replace(/\.py$/i, "");
    return base + ".txt";
  }
  function fallbackDownloadAsTxt() {
    const name = suggestedTxtNameFromCurrent();
    const blob = new Blob([cm.getValue()], { type: "text/plain" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = name;
    a.click();
    URL.revokeObjectURL(a.href);
  }

  saveBtn.addEventListener("click", async () => {
    if (!currentFile || !fileHandles.has(currentFile)) return;
    if (!isDirtyAgainstOriginal()) return;

    try {
      setStatus("Saving…");
      const handle = fileHandles.get(currentFile);
      const writable = await handle.createWritable();
      await writable.write(cm.getValue());
      await writable.close();

      const newText = cm.getValue();
      uploadedText.set(currentFile, newText);
      originals.set(currentFile, newText);

      setStatus("Saved");
      setSaveButtons();
    } catch (e) {
      setStatus("Save failed");
      writeln(String(e));
    }
  });

  saveAsBtn.addEventListener("click", async () => {
    try {
      if (!hasFS) {
        fallbackDownloadAsTxt();
        if (currentFile) originals.set(currentFile, cm.getValue());
        setStatus("Saved (downloaded)");
        setSaveButtons();
        return;
      }

      const handle = await window.showSaveFilePicker({
        suggestedName: suggestedTxtNameFromCurrent(),
        types: [{ description: "Text files", accept: { "text/plain": [".txt"] } }]
      });

      setStatus("Saving…");
      const writable = await handle.createWritable();
      await writable.write(cm.getValue());
      await writable.close();

      if (currentFile) {
        fileHandles.set(currentFile, handle);
        const newText = cm.getValue();
        uploadedText.set(currentFile, newText);
        originals.set(currentFile, newText);
      }

      setStatus("Saved");
      setSaveButtons();
    } catch (e) {
      if (String(e).includes("AbortError")) return;
      setStatus("Save As failed");
      writeln(String(e));
    }
  });

  /* ---------- Upload ---------- */
  async function openWithFSAccessPicker() {
    const [handle] = await window.showOpenFilePicker({
      multiple: false,
      types: [{ description: "Python or Text", accept: { "text/plain": [".txt"], "text/x-python": [".py"], "application/octet-stream": [".py"] } }]
    });

    const file = await handle.getFile();
    const rawName = file.name || "uploaded.txt";
    const internalName = rawName.replace(/\.(txt|py)$/i, ".py");
    const text = await file.text();

    ensureOptionExists(internalName);
    uploadedText.set(internalName, text);
    originals.set(internalName, text);
    fileHandles.set(internalName, handle);

    await loadProgram(internalName);
    setStatus("Ready (opened)");
  }

  uploadBtn.addEventListener("click", async () => {
    if (!confirmDiscardIfDirty("Uploading a file")) return;
    stopExecution("Stopped");

    try {
      if (hasFS) {
        await openWithFSAccessPicker();
      } else {
        fileInput.value = "";
        fileInput.click();
      }
    } catch (e) {
      if (String(e).includes("AbortError")) return;
      setStatus("Upload failed");
      writeln(String(e));
    }
  });

  fileInput.addEventListener("change", async () => {
    const file = fileInput.files && fileInput.files[0];
    if (!file) return;

    stopExecution("Stopped");

    const rawName = file.name || "uploaded.txt";
    const internalName = rawName.replace(/\.(txt|py)$/i, ".py");
    const text = await file.text();

    ensureOptionExists(internalName);
    uploadedText.set(internalName, text);
    originals.set(internalName, text);

    await loadProgram(internalName);
    setStatus("Ready (uploaded)");
    setSaveButtons();
  });

  /* ---------- Run ---------- */
  runBtn.onclick = () => {
    clearConsole();
    if (!worker) worker = makeWorker();
    running = true;
    runBtn.disabled = true;
    stopBtn.disabled = false;
    setStatus("Running…");
    worker.postMessage({ type: "run", code: cm.getValue() });
    consoleEl.focus();
  };

  /* ---------- UI init ---------- */
  const first = await loadProgramList();
  await loadProgram(first);

  // enable UI (worker loads python separately)
  reloadBtn.disabled = false;
  newBtn.disabled = false;
  clearBtn.disabled = false;
  programSel.disabled = false;
  saveBtn.disabled = true;
  saveAsBtn.disabled = false;
  uploadBtn.disabled = false;
  stopBtn.disabled = true;   // only enabled while running

  consoleEl.focus();
</script>
</body>
</html>
